using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using Tensorflow;
using NumSharp;
using static Tensorflow.Binding;
using SabberStoneUtil.DataProcessing;
using SurrogateModel.Logging;

namespace SurrogateModel.Surrogate
{
    /// <summary>
    /// Implementation of the fully connected surrogate neural network model.
    /// </summary>
    public class FullyConnectedNN : SurrogateBaseModel
    {
        /// <summary>
        /// Constructor of the FCNN model
        /// </summary>
        /// <param name = "num_epoch">Number of epochs to run during training. Default to 10</param>
        /// <param name = "batch_size">Batch size of data.</param>
        /// <param name = "step_size">The step size of adam optimizer.</param>
        /// <param name = "log_dir_exp">Path to the log directory.</param>
        public FullyConnectedNN(
            int num_epoch = 20,
            int batch_size = 64,
            float step_size = 0.01f,
            string log_dir_exp = "train_log",
            string offline_train_data_file = "resources/individual_log.csv",
            string offline_test_data_file = "resources/individual_log.csv",
            string[] model_targets = null)
            : base(num_epoch,
                   batch_size,
                   step_size,
                   log_dir_exp,
                   offline_train_data_file,
                   offline_test_data_file,
                   model_targets)
        {
            graph = build_graph();
            sess = tf.Session(config);
            sess.run(init); // initialize the graph
        }

        /// <summary>
        /// Prepare data for training
        /// </summary>
        /// <param name="online">If true, do online training with data generated by DeckSearch, else use locally generated data. Default to false.</param>
        /// <param name = "cardsEncoding">One hot encoded deck data used for training. Used only while training online.</param>
        /// <param name = "deckStats">Target deck data used for training. Used only while training online.</param>
        private void prepare_data(
            bool online = false,
            int[,] cardsEncoding = null,
            double[,] deckStats = null,
            bool testOutOfDist = false)
        {
            if (!online)
            {
                (cardsEncoding, deckStats) =
                    DataProcessor.PreprocessDeckOnehotFromFile(
                        offline_train_data_file, this.model_targets);
            }

            // Read in out-of-dist testing data, if any.
            NDArray X_out_dist = null, y_out_dist = null;
            if (testOutOfDist)
            {
                var (cardsEncodingOutDist, deckStatsOutDist) =
                    DataProcessor.PreprocessDeckOnehotFromFile(
                        offline_test_data_file, this.model_targets);
                X_out_dist = np.array(cardsEncodingOutDist);
                y_out_dist = np.array(deckStatsOutDist);
            }

            var X = np.array(cardsEncoding);
            X += np.random.normal(0, 1, X.shape) * 0.0001; // add random noise
            var y = np.array(deckStats);

            // could do more data preprocessing here if applicable

            init_data_loaders(X, y, X_out_dist, y_out_dist, testOutOfDist);
        }

        /// <summary>
        /// Establish computation graph
        /// </summary>
        private Graph build_graph()
        {
            // creat graph
            var g = tf.get_default_graph();

            // prepare data
            tf_with(tf.variable_scope("placeholder"), delegate
            {
                n_samples = tf.placeholder(tf.float32);
                input = tf.placeholder(tf.float32,
                                       shape: (-1, DataProcessor.numCards));
                y_true = tf.placeholder(tf.float32,
                                        shape: (-1, this.model_targets.Length));
            });

            // establish graph (architectur of neural net)
            var o_fc1 = fc_layer(input, name: "fc1", num_output: 128);
            var o_acti1 = elu_layer(o_fc1, name: "elu1");

            var o_fc2 = fc_layer(o_acti1, name: "fc2", num_output: 32);
            var o_acti2 = elu_layer(o_fc2, name: "elu2");

            var o_fc3 = fc_layer(o_acti2, name: "fc3", num_output: 16);
            var o_acti3 = elu_layer(o_fc3, name: "elu3");

            var o_fc4 = fc_layer(o_acti3, name: "fc4",
                                 num_output: this.model_targets.Length);
            model_output = o_fc4;

            // loss
            (loss_op, per_ele_loss_op) = mse_loss(model_output, y_true);

            // optimizer
            var adam =  tf.train.AdamOptimizer(step_size);
            train_op = adam.minimize(loss_op, name: "adam_train");

            init = tf.global_variables_initializer();

            return g;
        }



        /// <summary>
        /// offline fit the model using generated data
        /// </summary>
        public override void OfflineFit(bool testOutOfDist = false)
        {
            prepare_data(testOutOfDist: testOutOfDist);
            train();
        }

        /// <summary>
        /// online fit the model using specified data
        /// </summary>
        public override void OnlineFit(
            List<LogIndividual> logIndividuals,
            bool testOutOfDist = false)
        {
            var (cardsEncoding, deckStats) =
                DataProcessor.PreprocessDeckOnehotFromData(
                    logIndividuals, this.model_targets);
            prepare_data(online: true, cardsEncoding, deckStats, testOutOfDist);
            train();
        }

        /// <summary>
        /// Evaluate input, return output. Do not run before initialization
        /// </summary>
        public override double[,] Predict(List<LogIndividual> logIndividuals)
        {
            // obtain one hot encoding
            var (cardsEncoding, _) =
                DataProcessor.PreprocessDeckOnehotFromData(
                    logIndividuals, this.model_targets);
            var x_input = np.array(cardsEncoding);
            return PredictHelper(x_input);
        }
    }
}